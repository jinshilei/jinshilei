# 时间堆
1. 概念简述
由于定时器的触发是由于时间到了，因此只有时间最短的定时器会首先被触发，通过这个原理，我们可以采用最小堆，将按时间顺序排序，堆顶元素是时间最短的定时器，因此只要判断堆顶元素是否被触发即可。只有堆顶定时器的时间到了，才会到其他时间较晚的定时器的时间。

2. 实现细节
堆顶节点的删除：将堆顶节点删除，就会留有一个空位置，因此可以将最后一个节点放到堆顶位置，再对堆顶节点进行下滤，就可以确保构成最小堆。使用数组来模拟堆的实现，相比于链表而言，不仅节省空间，而且更容易实现堆的插入、删除操作。  
最小堆，可以用数组模拟堆:  
 对于第i个节点，其左子节点的位置是2i + 1， 右子节点的位置是2i + 2。对于具有N个节点的完全二叉树，其叶子节点有( N + 1 ) / 2个，非叶子节点有N / 2个。  
 由于在建立最小堆时，只要保证每个节点的值比其左右子节点都小即可，因此在建立最小堆时，只要从最下层开始，遍历前N / 2个非叶子节点( [ 0 ~ n/2-1 ] )进行下滤即可。（前提是已经有数组，不是每次向数组后面添加元素；叶子节点会由于其父节点的下滤而变得有序）  
 由于非叶子结点有N/2 - 1个，因此只要保证这些节点构成的子树具有堆性质，就能保证整棵树具有堆性质。（因为非叶子结点的下滤会将叶子节点也变的具有堆性质）

3. 最小堆的实现
由于堆是一种经过排序的完全二叉树，因此在构建的时候需要对新插入的节点进行一些操作以使其符合堆的性质。这种操作就是节点的上滤与下滤。  
上滤: 将当前节点与其父节点相比，如果当前节点的值比较小，就把当前节点与父节点交换，继续前面的比较，知道当前节点的值比父节点的值大为止。此时，便符合最小堆的定义。  
下滤： 将当前节点与其左、右子节点相比，如果当前节点的值比其中一个（或两个）子节点的值大，就把当前节点与两个子节点中较小的那个交换，继续前面的比较，知道当前节点的值比两个子节点的值都小为止。此时，便符合最小堆的定义。

4. 效率方面  
对时间堆而言，添加一个定时器的时间复杂
度是O（lgn），删除一个定时器的时间复杂度是O（1），执行一个定
时器的时间复杂度是O（1）