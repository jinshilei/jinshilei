# 利用标准库容器vector封装char，实现自动增长的缓冲区  
实现原理：  
1. 首先在内存中创建一个缓冲区，缓冲区的大小为1024字节，同时定义两个指针，一个读指针，表示的是可以读取的数据的开始位置，一个写指针表示的是可以写入数据的起始位置，开始的时候两个指针都是指向内存开始的地方  
2. 当有文件描述符监听到事件的发生的时候，比如发生的是读事件，那么就要把文件描述符监听到的事件读取到缓冲区，加入读取的字节的长度为len，那么写指针的位置就要发生变化，移动到len位置  
3. 因为缓冲区的大小是固定的大小，而我们通常是一次性将数据全部读取到缓冲区，就有可能装不下数据，所以需要临时创建一个缓冲区来缓解，将存不下的放到临时缓冲区，这样就可以一次性将所有的数据读入，这里利用临时缓冲区的技术是一个分散读的技术，即将数据分散读取到内存中不同的位置，分散读的话需要定义一个结构体数组:
struct iovec{
    void* iov_base;//缓冲区地址
    size_t iov_len;//缓冲区的大小
};  
4. 当固定的缓冲区想要继续写数据的时候，发现剩余的位置不够写的时候那么就可以先把数据写入到临时缓冲中，再将临时数组的数据读取到固定缓冲区来处理，因为数据的处理只能放到固定大小的缓冲中进行处理，即上述的1024字节的缓冲中，那么如果很多数据都读取到这块区域的话，那么肯定是放不下的，我们就可以利用一个临时的缓冲区，把放不下的数据先放到临时的缓冲的位置，等到1024字节大小的内存有剩余的空间的时候我再将临时缓冲区的数据放入到1024的位置进行处理。
5. 当读指针移动以后，写指针还有一段没写，如果还想写入数据，可以利用前面已经读过数据的空间，将中间数据复制到最前面的，让空闲区域连接在一起，然后移动读写指针位置就可以实现了自动增长的缓冲区。

未来优化：实现循环缓冲区